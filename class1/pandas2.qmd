---
title: "Data exploration"
format:
  html:
    code-fold: false
    code-line-numbers: true
    css: [../assets/webex.css]
    include-after-body: [../assets/webex.js]
    embed-resources: true 
jupyter: python3
---

```{python}
#| echo: false
from pywebexercises.exercises import mcq, longmcq, torf
import matplotlib.pyplot as plt
plt.rcParams.update({
    "figure.facecolor":  (0.0, 0.0, 0.0, 0.0),  # red   with alpha = 30%
})
```

## Introduction

### Today's objectives {.unnumbered}

## Setting up the exercise

We start by importing libraries and the dataset.

```{python}
#| echo: true
#| lst-label: lst-load-geochem
#| lst-cap: caption

# Load libraries
import pandas as pd # Import pandas
import matplotlib.pyplot as plt # Import the pyplot module from matplotlib
import seaborn as sns # Import seaborn

# Import the dataset specifying which Excel sheet name to load the data from
df = pd.read_excel('../Data/Smith_glass_post_NYT_data.xlsx', sheet_name='Supp_traces')
```

As in [the previous class](pandas1.qmd), we load the dataset using **Pandas**. The dataset comes from @Smith2011 and contains the chemical concentrations in volcanic tephra belonging to the recent activity (last 15 ky) of the Campi Flergrei Caldera (Italy). The dataset is contained in an Excel file that contains two sheets named `'Supp_majors'` and `'Supp_traces'`. In @lst-load-geochem, we use the `sheet_name` argument to the `read_excel()` ([doc](https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html)) function to specify that we want to load the sheet containing trace elements.

::: {.callout-tip}
## Good reference book

The use of this dataset is inspired by the by the book *Introduction to Python in Earth Science Data Analysis: From Descriptive Statistics to Machine Learning* by @Petrelli2021.
:::


### Basics of plotting in Python {.unnumbered}

@lst-load-geochem also loads two libraries for plotting:

- [**Matplotlib**](https://matplotlib.org/stable/users/explain/quick_start.html) is [the library]{.mark} for plotting in Python. It allows for the finest and most comprehensive level of customisation, but it take some time to get used to. You can visit the [gallery](https://matplotlib.org/stable/gallery/index.html) to get some inspiration.
- [**Seaborn**](https://seaborn.pydata.org/tutorial/introduction) is [built on Matplotlib]{.mark}, but provides some higher-level functions to easily produce stats-oriented plots. It looks good by default, but finer customisation might be difficult and might result to using Matplotlib. Again, check out the [gallery](https://seaborn.pydata.org/examples/index.html).

Here again, the idea is not to make you expert in *Matplotlib* or *Seaborn*, but rather to provide you with the minimum knowledge for you to further explore this tools in the context of your research.

#### Components of a Figure {.unnumbered}

Let's start to look at the basic components of a *Matplotlib* figure. There are two "hosts" to any plot (@fig-fig-anatomy-1):

1. A [**Figure**]{.mark} represents the main canevas;
2. [**Axes**]{.mark} are contained within the figure and is where most of the plotting will occur.

The easiest way to define a figure is using the `subplots()` function (@lst-plt-set). Note that the code returns two variables - `fig` and `ax` - which are the figure and the axes, respectively.

```{python}

#| eval: false
#| lst-label: lst-plt-set
#| lst-cap: Define a figure and one axes.
#| 
import matplotlib.pyplot as plt
fig, ax = plt.subplots()
```

![Main figure and axes of a *Matplotlib* figure](img/fig-anatomy-1.png){#fig-fig-anatomy-1}


Most additional components of a plot are controlled via the `ax` variable, which can be used to (@fig-fig-anatomy-2):

- *Plot* (e.g., line plot or scatter plots)
- *Set labels* (e.g., x-label, y-label, title)
- Add various *components* (e.g., legend, grid)

![Basic components of a *Matplotlib* figure](img/fig-anatomy-2.png){#fig-fig-anatomy-2}

::: {.callout-note}

## Plotting exercise

@lst-plt-ex1 defines a figure and plots some data. @tbl-mpl-basics and @fig-fig-anatomy-2 illustrate some of the most frequently used functions for customising plots.

Use these functions to customise @lst-plt-ex1. Some hints:

- Remember that a *function* takes some *arguments* provided between *parentheses* (e.g., `ax.title(argument)`). Each function might accept different types of arguments.
- Titles and labels require a *string*, so remember to use `" "` or `' '`.
- For now, the legend does not require any argument, so you can leave the parentheses empty.
- Setting the grid requires one argument: do we want to show the grid (`True`) or not (`False`)

:::

| Function        | Description                        | Argument Type         | Example Argument           |
|-----------------|------------------------------------|-----------------------|----------------------------|
| [`ax.set_title`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_title.html)    | Sets the title of the axes         | str                   | "My Plot Title"            |
| [`ax.set_xlabel`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_xlabel.html)   | Sets the label for the x-axis      | str                   | "X Axis Label"             |
| [`ax.set_ylabel`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_ylabel.html)   | Sets the label for the y-axis      | str                   | "Y Axis Label"             |
| [`ax.legend`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html)       | Displays the legend                | None    | None (default)  |
| [`ax.grid`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.grid.html)         | Shows grid lines                   | bool           | True             |

: Some of the most frequently used plotting functions. {#tbl-mpl-basics .striped   }

```{python}

#| lst-label: lst-plt-ex1
#| lst-cap: Define a figure and one axes.

import matplotlib.pyplot as plt # Import matplotlib

# Define some data
data1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
data2 = [7, 3, 9, 1, 5, 10, 8, 2, 6, 4]

# Set the figure and the axes
fig, ax = plt.subplots()

# Plot the data
ax.plot(data1, data1, color='aqua', label='Line')
ax.scatter(data1, data2, color='purple', label='scatter')

# Customise the plot - up to you!
# - Add a title
# - Add x and y labels
# - Add a legend
# - Add a grid
```


### Plotting with Seaborn {.unnumbered}

Let's now review the use of **Seaborn**. You might wonder [why do we need another plotting library]{.mark}. Well, the topic of this module is [data exploration]{.mark}, and this is exactly what *Seaborn* is designed for. In additions, *Seaborn* is designed to work with *Pandas*.

Over the next steps of the exercise we will use various types of plots offered by *Seaborn* to explore our geochemical dataset. @lst-sns-intro illustrates how to create a [scatterplot](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) of the [Rubidium]{.mark} and [Strontium]{.mark} values contained in our dataset `df`. *Seaborn* usually takes [4 arguments]{.mark}:

1. `ax`: The axes on which to plot the data
2. `data`: The DataFrame containing the data.
3. `x`: The name of the column containing the values used along x
4. `y`: The name of the column containing the values used along y

```{python}

#| lst-label: lst-sns-intro
#| lst-cap: Basic plotting using Seaborn.

# Define figure + axes
fig, ax = plt.subplots()
# Plot with seaborn (remember, we imported it as sns)
# df is the geochemical dataset imported previously
sns.scatterplot(ax=ax, data=df, x='Rb', y='Sr')
```


Should you feel adventurous and check out the [documentation](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) of the `scatterplot` function, you would see that it is possible to use [additional arguments]{.mark} to further customize the plot:

- `hue`: Name of the variable that will produce points with [different colors]{.mark}.
- `size`: Name of the variable that will produce points with [different sizes]{.mark}.

::: {.callout-note}

## Seaborn exercise

Complete @lst-sns-intro, but use:

- The `"Epoch"` column to control points color.
- The `"SiO2* (EMP)"` column to control points size.

Remember, you can use `df.columns` to print a list of column names contained in the DataFrame.

:::



## Descriptive statistics


### Univariate statistics  {.unnumbered}

The objective of **descriptive statistics** is to [provide ways of capturing the properties of a given data set or sample]{.mark}. Using *Pandas* and *Seaborn*, we will review some [metrics, tools, and strategies]{.mark} that can be used to summarize a dataset, providing us with a quantitative basis to talk about it and compare it to other datasets.

By **univariate statistics**, we focus on [capturing the properties of **single** variables at the time]{.mark}. We are not yet concerned in characterising the [relationships]{.mark} between two or more variables.

Let's focus on the Zircon concentration in Campi Flegrei's geochemical dataset. Let's start by simply [visualising]{.mark} the dataset to get an understanding of what we will talk about. Figures below illustrate three different plot types:

1. **Histograms** ([`sns.histplots()`](https://seaborn.pydata.org/generated/seaborn.histplot.html)) show the [number of times a specific Zr concentration occurs]{.mark} in our dataset (@lst-sns-hist).
2. **Box plots** ([`sns.boxplot()`](https://seaborn.pydata.org/generated/seaborn.boxplot.html) - or box-and-whisker plot) show the [distribution of quantitative data]{.mark} with some measure of dispersion. Note that they are useful to compare between variables (@lst-sns-boxplot). 
3. **Violin plots** ([`sns.violinplot()`](https://seaborn.pydata.org/generated/seaborn.violinplot.html)) are similar to box plots, but they approximate the underlying data distribution using some smoothing algorithm (i.e. *kernel density estimation*). Without going into too much detail, this provides a good first approximation of the distribution, but [it can create some unrealistic artefacts]{.mark} (e.g., see the negative Sr concentrations in @lst-sns-violinplot).

::: {.panel-tabset}

## Histogram

```{python}
#| lst-label: lst-sns-hist
#| lst-cap: Visualising distributions using histograms.

fig, ax = plt.subplots()
sns.histplot(data=df, x='Zr')
ax.set_xlabel('Zr (ppm)');
ax.set_title('Zr distribution');
```

## Box plot

::: {.callout-tip}
## Plotting several columns

Box plots are useful to plot and compare more than one data. @lst-sns-boxplot slightly adjusts how `boxplot()` is called to allow for that.

:::

```{python}
#| lst-label: lst-sns-boxplot
#| lst-cap: Visualising distributions using box-and-whisker plots.

fig, ax = plt.subplots()
sns.boxplot(data=df[['Zr', 'Sr']]) # We plot Zr and Sr together using a list
ax.set_ylabel('Concentration (ppm)');
ax.set_title('Zr and Sr distribution');
```

## Violin plot

```{python}
#| lst-label: lst-sns-violinplot
#| lst-cap: Visualising distributions using violin plots.

fig, ax = plt.subplots()
sns.violinplot(data=df[['Zr', 'Sr']])
ax.set_xlabel('Concentration (ppm)');
ax.set_title('Zr and Sr distribution');
```

:::


By looking at the Zr and St distributions from the figures above, we can intuitively understand the importance of describing [three different parameters]{.mark}:

- The **location** - or where is [the central value(s)]{.mark} of the dataset;
- The **dispersion** - or how [spread out]{.mark} is the distribution of data compared to the central values;
- The **skewness** - or how [symmetrical]{.mark} is the distribution of data compared to the central values;


#### Location {.unnumbered}

##### Mean {.unnumbered}

The **mean** (or *arithmetic* mean - by opposition to *geometric* or *harmonic* means) is the [sum of the values divided by the number of values]{.mark} (@eq-mean):

$$
\bar{x} = \frac{1}{n} \sum_{i=1}^{n} x_i
$$ {#eq-mean}

The mean is meaningful to describe [**symmetric** distributions without **outliers**]{.mark}, where:

- **Symmetric** means the number of items above the mean should be roughly the same as the number below;
- **Outliers** are *extreme* values.

The mean of a dataset can easily be computed with *Pandas* using the [`.mean()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html) function (@lst-univ-mean). Note that we round the results to two significant digits using `.round(2)`.

```{python}
#| lst-label: lst-univ-mean
#| lst-cap: Compute the mean for two significant digits.

df['Zr'].mean().round(2)
```


::: {.callout-note}
## Question

What is the mean value for Strontium?

```{python}
#| echo: false
mcq({
    '365.38' : 0,
    '516.42' : 1,
    '219.38' : 0,
    '123.94' : 0,
})
```

:::





::: {.callout-tip}
## Descriptive stats functions

@lst-univ-mean shows how to compute the mean on one column, but the `.mean()` function - as well as most fuctions for descriptive stats - can be applied to entire DataFrames. For this, we need to understand a critical argument - `axis`.

- `axis = 0` is usually the default, and computes the mean [across all rows for each column]{.mark}(@lst-univ-mean-multi-row)
- `axis = 1` usually makes sense when rows are labelled, and computes the mean [across all columns for each row]{.mark}(@lst-univ-mean-multi-col)

```{python}
#| lst-label: lst-univ-mean-multi-row
#| lst-cap: Compute the mean across rows.
# Create a subset of the df containing numerical data
df_sub = df[['Sc','Rb','Sr','Y','Zr','Nb','Cs']] 
# Compute the mean across all rows
df_sub.mean(axis=0).round(2).head()

```

```{python}
#| lst-label: lst-univ-mean-multi-col
#| lst-cap: Compute the mean across columns.

# Create a subset of the df containing numerical data
df_sub = df[['Sc','Rb','Sr','Y','Zr','Nb','Cs']] 
# Compute the mean across all columns
df_sub.mean(axis=1).round(2).head()
```


:::




##### Median {.unnumbered}

The **median** is the value [at the exact middle of the dataset]{.mark}, meaning that just as
many elements lie above the median as below it. There is no easy formula to compute the median, instead we need to conceptually (@lst-univ-median-ex):

1. Order all values in ascending order and plot them against a normalised number of observations (this is called an empirical cumulative density function - or ECDF);
2. On the x-axis, find the point dividing the dataset into two equal numbers of observations;
3. Read the value on the y-axis that intersects the ECDF.

```{python}
#| lst-label: lst-univ-median-ex
#| lst-cap: Graphical representation of the median.

fig, ax = plt.subplots()
sns.ecdfplot(data=df, y='Zr')
ax.plot([.5,.5], [0, df['Zr'].median()], color='orange', linestyle='--')
ax.plot([.5,0], [df['Zr'].median(), df['Zr'].median()], color='orange', linestyle='--')
ax.set_ylim([0,900])
```

Fortunately, we can also use the native *Pandas* [`.median`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html) function (@lst-univ-median). 

```{python}
#| lst-label: lst-univ-median
#| lst-cap: Compute the median for two significant digits.
round(df['Zr'].median(), 2)
```

::: {.callout-note}
## Question

What is the mean value for Cesium?

```{python}
#| echo: false
mcq({
    '36.38' : 0,
    '51.42' : 1,
    '23.99' : 1,
    '13.94' : 0,
})
```

:::


<!-- ##### Mode {.unnumbered}

[mode](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html)
 -->

##### Summary {.unnumbered}

@lst-univ-mean-med illustrate the values of the mean and the median relative to the distribution shown in the histogram. There are a few things to keep in mind when choosing between mean and median to estimate the location of a dataset:

- If a sample has a [symmetrical distribution]{.mark}, then **the mean and median are equal**.
- If the distribution of a sample is [not symmetrical]{.mark}, **the mean should not be used**.
- The [mean is highly sensitive to outliers]{.mark}, whereas the median is not.


```{python}
#| lst-label: lst-univ-mean-med
#| lst-cap: Compute the median for two significant digits.
#| 
fig, ax = plt.subplots()
sns.histplot(data=df, x='Zr')
ax.axvline(df['Zr'].mean(), color='darkorange', lw=3, label='Mean')
ax.axvline(df['Zr'].median(), color='darkviolet', lw=3, label='Median')
ax.legend()
```



#### Dispersion {.unnumbered}

##### Range {.unnumbered}

The first information we might want to get for a dataset is the range of values it covers, or *range*. For this, we need to get the minimum (`df.min()`) and maximum (`df.max()`) values, from which, when needed, the range can be calculated with @eq-range. It is however likely that the min/max functions will be more frequently used (@lst-univ-minmax).

$$
\text{Range} = \max(x) - \min(x)
$$ {#eq-range}


```{python}
#| lst-label: lst-univ-minmax
#| lst-cap: Compute the min and the max values of a column

df['Zr'].min()
df['Zr'].max()

```


::: {.callout-note}
## Question

What is the mean value for Cesium?

```{python}
#| echo: false
mcq({
    '10.46' : 0,
    '104.66' : 1,
    '1045.59' : 1,
    '10455.91' : 0,
})
```

:::

##### Variance and standard deviation {.unnumbered}

The **variance** and **standard deviation** are two key measures of dispersion that describe how spread out the values in a dataset are.

- **Standard deviation** ($\sigma$) measures sum of squares differences between data points $x_i$ and the
mean $\bar{x}$:
    $$
    \sigma = \sqrt{\frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}{n-1} }
    $$
    where $x_i$ are the data points, $\bar{x}$ is the mean, and $n$ is the number of observations.

- **Variance** ($\sigma^2$) is the square of the standard deviation:
    $$
    \sigma^2 = \frac{\sum_{i=1}^{n} (x_i - \bar{x})^2}{n-1} 
    $$
    

For now we will consider that they roughly measure the same thing. The standard deviation is in the same units as the data, making it easier to interpret.

**Relation to the Gaussian distribution:**  
For a Gaussian (normal) distribution, about 68% of the data falls within one standard deviation of the mean, about 95% within two standard deviations, and about 99.7% within three standard deviations. Thus, variance and standard deviation are fundamental for describing the spread and probability intervals of normally distributed data.

You can compute these in pandas using `.var()` and `.std()`:


#### Skewness x {.unnumbered}

### Bivariate statistics x {.unnumbered}

#### Correlation x {.unnumbered}

#### Simple linear regression x {.unnumbered}