---
title: "Querying data"
format:
  html:
    code-fold: false
    code-line-numbers: true
    css: [../assets/webex.css]
    include-after-body: [../assets/webex.js]
    embed-resources: true 
jupyter: python3
---

```{python}
#| echo: false
from pywebexercises.exercises import mcq, longmcq, torf
import matplotlib.pyplot as plt
plt.rcParams.update({
    "figure.facecolor":  (0.0, 0.0, 0.0, 0.0),  # red   with alpha = 30%
})
import pandas as pd
df = pd.read_csv('https://raw.githubusercontent.com/e5k/Data-Science/main/Data/dummy_volcanoes.csv', parse_dates=['Date']) # Load data
df = df.set_index('Name')
```

## Querying data from a DataFrame {.unnumbered}

Let's now review how we can access data contained in the DataFrame. This process, known as *indexing*, consists in specifying a row or a column (or ranges of rows and columns) where the data is stored. In `pandas`, there are two different ways to do that:

- By `label`: data is queried using the actual index/column name (e.g., the `VEI` column in the DataFrame above)
- By `location`: data is queried using the column location (e.g., the 3rd row)

### Label-based indexing {.unnumbered}

![Label-based queries using `.loc`.](img/pandas_loc.png){#fig-pandas-loc}

#### Querying rows {.unnumbered}

When we know the exact label of the row or the column, we can use the `.loc` function to query the DataFrame (@fig-pandas-loc). Let's start by querying specific **rows**. We have [previously](day1-3_data_exploration.qmd#lst-set-index) defined the `Name` column as the *index* (i.e., row label), which means that we can simply pass the name of the volcano.

```{python}
# Get the row for "Calbuco" volcano
df.loc['Calbuco']

```

Note that the result is a *Series* (i.e., a 1-dimensional DataFrame where the columns become the index), not a DataFrame. If we want to **keep it as a DataFrame**, we can use double brackets. Double brackets can also be used to query **multiple rows**.

```{python}
df.loc[['Calbuco']] # Query one row and return it as a DataFrame
df.loc[['Calbuco', 'Taal']] # Query multiple rows
```

::: {.callout-note}
## Question

What is the VEI recorded for Etna volcano?

```{python}
#| echo: false
mcq({
    '1' : 0,
    '2' : 0,
    '3' : 0,
    '4' : 1,
    '5' : 0
})
```

What is the eruption date for Taal volcano?

```{python}
#| echo: false
mcq({
    '1980-05-18	' : 0,
    '1991-04-02' : 0,
    '2020-01-12' : 1,
    '1997-06-25' : 0,
    '2023-02-13' : 0
})
```

:::


::: {.callout-tip}
## Double brackets
In general, double brackets ``[[ ]]`` will return a DataFrame and not a Series. We will dominantly use this in the following examples.
:::


#### Querying columns {.unnumbered}

Let's now query specific **columns**. For example, querying the `VEI` column can be achieved in different ways. The simplest is to use the column name directly. We can also query **multiple columns** using double brackets


```{python}
df[['VEI']] # Get the VEI column
df[['Country', 'VEI']] # Query multiple columns
```


Note that until now, we have only retrieved either rows or columns (@fig-pandas-loc). We can also retrieve specific values by specifying **both the row and the column**.

```{python}
df.loc[['Calbuco', 'Taal']][['Country', 'VEI']]
```

### Position-based indexing {.unnumbered}

::: {#cau-indexing .callout-caution}
## Indexing in Python
Remember that in Python, indexing starts from 0 - so the first row or column has an index of 0.
:::

![Position-based queries using `.iloc`.](img/pandas_iloc.png){#fig-pandas-iloc}


Some situations require querying data by *location* instead of *label* - let's say for instance we need to retrieve rows 10-20. This is done using the `.iloc` function (instead of the `.loc` function previously used; @fig-pandas-iloc). Remember that Python uses zero-based indexing (@cau-indexing), meaning that the first element is at position 0, the second at position 1, and so on.

The next example queries the first row - using again double brackets to return a **DataFrame**.

```{python}
df.iloc[[0]]
```

#### Get ranges of rows {.unnumbered}

We can get **a range of rows** using what is called *slicing*. This is done using the colon (`:`) operator. The next example queries rows 3 to 6 of the DataFrame. Note that the end index is exclusive, meaning that the element at the end index is not included in the result.

```{python}
df.iloc[2:6]
```

To get rows 3 to 6 and columns 2-3:

```{python}
df.iloc[0:5, 1:3]
```

#### Count rows from the last {.unnumbered}

To get the last 5 rows of the DataFrame:

```{python}
df.iloc[-5:]
```

#### Combining position-based and label-based queries {.unnumbered}

By experience, position-based queries is more used on *rows* than *columns*. For instance, we might want to access the first 10 rows because we don't know their associated labels, yet it is less likely that we ignore their *attributes*.
It is possible mix label-based and position-based indexing. For example, to get the first 5 rows and the `Country` and `VEI` columns:


```{python}
df.iloc[0:5][['Country', 'VEI']]
```

