{
  "hash": "10fd89dde6c35217bc67fedbed74e0ba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Intro to Pandas\"\nformat:\n  html:\n    code-fold: false\n    code-line-numbers: true\n    css: [../assets/webex.css]\n    include-after-body: [../assets/webex.js]\n    embed-resources: true \njupyter: python3\n---\n\n\n\n## Introduction\n\nWe will start our data science journey by learning a bit about the most useful Python library for this class: **Pandas**. As a reminder, a *library* is a set of tools we load on top of Python that provides new functionalities for a specific problem or type of analysis. Here, Pandas provides functions for **data manipulation and analysis**, handling structured data like tables or time series and facilitating numerous tasks you might encounter as a scientist. These include:\n\n- **Reading/writing data** from various commonly-used formats (CSV, Excel, SQL, JSON, etc.)\n- Handling **missing data**\n- **Filtering**, **sorting**, **reshaping** and **grouping** data\n- **Aggregating** data (sum, mean, count, etc.)\n- **Time series support** (date ranges, frequency conversions)\n- **Statistical operations**\n\n### Today's objectives {.unnumbered}\n\nThe objective of this class is by no way to make you an expert in Pandas and data science. Rather, the objective is to take you through the most basic manipulations in order to build the confidence to keep on exploring the use of scientific coding and to include it into your research pipeline. The objectives of this module are to review:\n\n- [x] What is a Pandas DataFrame and its basic anatomy\n- [x] How to *load data* in a DataFrame\n- [x] How to *access* data (e.g., query by label/position)\n- [x] How to *filter* data (e.g., comparison and logical operators)\n- [x] How to *rearrange* data (e.g., sorting values)\n- [x] How to *operate* on data (e.g., arithmetic and string operations)\n\nWe first start by reviewing the [data structure](#pandas-data-structure) behind Pandas, then we will move on to a [coding exercise](#coding-playground) to make you familiar with some basic functionalities.\n\n## Pandas data structure\n\nPandas consists of two main types of **data structures**. Let's make an analogy with Excel.\n\n1. **Series**: A 1D labeled array. Think of a 2-columns Excel spreadsheet where the left column would contain a *label* (e.g., the time of a measurement) and the right column would contain a *value* (e.g., the actual value measured at the time specified in the label, let's say the temperature of a river).\n2. **DataFrame**: A 2D labeled table. This is the same as an Excel spreadsheet that would contain more columns than a Series. You can think of having measurements of different variables contained in each column (e.g., the flow rate, the turbidity etc...).\n\nThe keyword here is **labelled**. In Excel, you might get a column using *letters* and rows using *numbers*. In Pandas, you can use the column name (e.g., `water_temperature`) or the row label (e.g., `2021-06-15 14:19:14`).\n\n\n::: {.callout-note}\n## DataFrame\nThroughout this class we will focus on the use of **DataFrames**, not Series. Keep in mind that the behaviour between both is almost identical.\n:::\n\n### Anatomy of a DataFrame {.unnumbered}\n\n@fig-anatomy shows the basic anatomy of a DataFrame that contains four **rows** and four **columns**). We already see some data structuring emerging:\n\n- *Rows* tend to represent **entries**, which can be:\n  - Different measurements at specific time steps\n  - Different samples collected at different place/times\n  - etc.\n- In contrast, *column* represent **attributes** and store the properties of each entry:\n  - The actual values of different measured parameters\n  - The location and time of collected samples, along with associated analyses (e.g., geochemistry)\n  - etc.\n\n\n\n![Basic anatomy of a Pandas DataFrame.](img/pandas-1.png){#fig-anatomy}\n\nThe first row - i.e. the row containing the column *labels* - is not considered as an entry. This is because the **top row** of a dataframe is usually used as the *label* for the **columns**. Similarly, we might want to set the **first column** as a *label* for the **rows** (@fig-index). In a nutshell:\n\n- **Index** refers to the label of the **rows**. In the *index*, **values are usually unique** - meaning that each entry has a different label.\n- **Column** refers to the label of - logically - the **columns**\n\n![Index and columns of a DataFrame.](img/pandas-2.png){#fig-index}\n\n::: {#cau-indexing .callout-caution}\n## Indexing in Python\nRemember that in Python, indexing starts from 0 - so the first row or column has an index of 0.\n:::\n\n\n\n\n## Coding playground\n\nLet's get our hands dirty and start coding. Create a new Jupyter notebook following [this guide](../appendices/setup_vscode.qmd). You can copy fragments of the code, but make sure each code block is a different cell in you notebook. Also remember that you can add **Markdown** cells in between code cells, which are really useful to document your code.\n\nThe data we will use here is a `csv` file containing selected eruptions of the past 50 years. The first 5 rows of the data are illustrated in @tbl-first-5.\n\n\n| Name            | Country     | Date                |   VEI |   Latitude |   Longitude |\n|:----------------|:------------|:--------------------|------:|-----------:|------------:|\n| St. Helens      | USA         | 1980-05-18 00:00:00 |     5 |    46.1914 |   -122.196  |\n| Pinatubo        | Philippines | 1991-04-02 00:00:00 |     6 |    15.1501 |    120.347  |\n| El Chichón      | Mexico      | 1982-03-28 00:00:00 |     5 |    17.3559 |    -93.2233 |\n| Galunggung      | Indonesia   | 1982-04-05 00:00:00 |     4 |    -7.2567 |    108.077  |\n| Nevado del Ruiz | Colombia    | 1985-11-13 00:00:00 |     3 |     4.895  |    -75.322  |\n\n: First 5 rows of the dataset. {#tbl-first-5 .striped   }\n\n::: {.callout-note collapse=\"true\"}\n## What is the VEI?\n\nThe Volcanic Explosivity Index - or VEI - is a scale to measure the magnitude of explosive eruptions based on the volume of tephra ejected during an eruption. It is a logarithmic scale in base 10:\n\n| VEI | Min Volume (km³) | Max Volume (km³) | Approx. Frequency      |\n|-----|------------------|------------------|------------------------|\n| 0   | <0.00001         | 0.0001           | Daily                  |\n| 1   | 0.0001           | 0.001            | Weekly                 |\n| 2   | 0.001            | 0.01             | Yearly                 |\n| 3   | 0.01             | 0.1              | Few per year           |\n| 4   | 0.1              | 1                | ~10 per decade         |\n| 5   | 1                | 10               | ~1 per decade          |\n| 6   | 10               | 100              | ~1 per century         |\n| 7   | 100              | 1000             | ~1 per several centuries|\n| 8   | >1000            | -                | ~1 per 10,000 years    |\n\n: VEI scale with minimum and maximum erupted volume and approximate frequency. {#tbl-vei .striped   }\n\n:::\n\n### Importing the library and the data {.unnumbered}\n\nAs always, we start by importing the `pandas` library as `pd`.\n\n::: {#load-packages .cell output-fold='true' output-summary='Show output' execution_count=2}\n``` {.python .cell-code}\nimport pandas as pd\n```\n:::\n\n\nWe load the dataset using the `pd.read_csv` function into a variable called `df` (for DataFrame) ([doc](https://pandas.pydata.org/docs/reference/api/pandas.read_csv.html)). Remember that *functions* can take different *arguments*, which are extra keywords you can *pass* to make the behaviour of the function more specific to your need. Here, we pass one arguments to the `read_csv()` function: `parse_dates=['Date']` Specifies that the `Date` column should be treated as a date object.\n\n\n<!-- ::: {.callout-tip}\n## Function arguments\n\nRemember that *functions* can take different *arguments*, which are extra keywords you can *pass* to make the behaviour of the function more specific to your need. Here, we one arguments to the `read_csv()` function:\n\n- `index_col=0`: Specify that the index of the file is the first column. More on that soon if this is unclear.\n- `parse_dates=['Date']`: Specify that the `Date` column should be treated as a date object.\n::: -->\n\n::: {#aefa2684 .cell execution_count=3}\n``` {#lst-load-data .python .cell-code lst-cap=\"Loading data from a csv file\"}\ndf = pd.read_csv('data/dummy_volcanoes.csv', parse_dates=['Date']) # Load data\ndf.head() # Show the first 5 rows\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Name</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>VEI</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>St. Helens</td>\n      <td>USA</td>\n      <td>1980-05-18</td>\n      <td>5</td>\n      <td>46.1914</td>\n      <td>-122.1956</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>Pinatubo</td>\n      <td>Philippines</td>\n      <td>1991-04-02</td>\n      <td>6</td>\n      <td>15.1501</td>\n      <td>120.3465</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>El Chichón</td>\n      <td>Mexico</td>\n      <td>1982-03-28</td>\n      <td>5</td>\n      <td>17.3559</td>\n      <td>-93.2233</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>Galunggung</td>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n      <td>4</td>\n      <td>-7.2567</td>\n      <td>108.0771</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>Nevado del Ruiz</td>\n      <td>Colombia</td>\n      <td>1985-11-13</td>\n      <td>3</td>\n      <td>4.8950</td>\n      <td>-75.3220</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n#### Setting up the index {.unnumbered}\n\nThe output of @lst-load-data shows the first 5 rows in our DataFrame. As displayed in @fig-index, the first column is the *index* - which is currently just integer numbers. That can be acceptable in some cases, but for the sake of the exercise we will choose one column to become the index - here `Name`. \n\n@lst-set-index Illustrates the use of two useful functions:\n\n- `.set_index()`: Uses a column as the DataFrame's index\n- `.reset_index()`: Removes the column's index back to a sequential numbering as in @lst-load-data.\n\n::: {#fb7c4eec .cell execution_count=4}\n``` {#lst-set-index .python .cell-code lst-cap=\"Common functions to set the index of a DataFrame\"}\ndf = df.set_index('VEI') # Set the 'VEI' column as an index\ndf = df.reset_index() # Shoots, I meant to set the 'Name' columns as an index\ndf = df.set_index('Name') # Here we go.\ndf.head()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>St. Helens</th>\n      <td>5</td>\n      <td>USA</td>\n      <td>1980-05-18</td>\n      <td>46.1914</td>\n      <td>-122.1956</td>\n    </tr>\n    <tr>\n      <th>Pinatubo</th>\n      <td>6</td>\n      <td>Philippines</td>\n      <td>1991-04-02</td>\n      <td>15.1501</td>\n      <td>120.3465</td>\n    </tr>\n    <tr>\n      <th>El Chichón</th>\n      <td>5</td>\n      <td>Mexico</td>\n      <td>1982-03-28</td>\n      <td>17.3559</td>\n      <td>-93.2233</td>\n    </tr>\n    <tr>\n      <th>Galunggung</th>\n      <td>4</td>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n      <td>-7.2567</td>\n      <td>108.0771</td>\n    </tr>\n    <tr>\n      <th>Nevado del Ruiz</th>\n      <td>3</td>\n      <td>Colombia</td>\n      <td>1985-11-13</td>\n      <td>4.8950</td>\n      <td>-75.3220</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n#### Basic data exploration {.unnumbered}\n\nLet's now explore the structure of the dataset with the following functions:\n\n| Function         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n|------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `df.head()`      | Prints the *first* 5 rows of the DataFrame ([doc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.head.html))                                                                                                                                                                                                                                                                                                                          |\n| `df.tail()`      | Prints the *last* 5 rows of the DataFrame ([doc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.tail.html))                                                                                                                                                                                                                                                                                                                           |\n| `df.info()`      | Displays some info about the DataFrame, including the number of rows (*entries*) and columns ([doc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.info.html)). Note the `Dtype` column: this is the type variable stored in each column including *strings* (`object`), *integer* (`int64`) and *float* (`int64`) numbers. See that the `Date` column is indeed stored as a `datetime` variable as requested above. |\n| `df.shape`       | Returns a list containing the number of rows and columns of the DataFrame.                                                                                                                                                                                                                                                                                                                                                                           |\n| `df.index`       | Returns a list containing the index along the *rows* of the DataFrame.                                                                                                                                                                                                                                                                                                                                                                           |\n| `df.columns`     | Returns a list containing the index along the *columns* of the DataFrame.                                                                                                                                                                                                                                                                                                                                                                           |\n\n::: {.callout-tip}\n\n## Your turn!\n\nTry these functions on `df` and get familiar with the output.\n\n:::\n\n\n### Querying data {.unnumbered}\n\nLet's now review how we can access data contained in the DataFrame. This process, known as *indexing*, consists in specifying a row or a column (or ranges of rows and columns) where the data is stored. In `pandas`, there are two different ways to do that:\n\n- By `label`: data is queried using the actual index/column name (e.g., the `VEI` column in the DataFrame above)\n- By `location`: data is queried using the column location (e.g., the 3rd row)\n\n#### Label-based indexing {.unnumbered}\n\n![Label-based queries using `.loc`.](img/pandas_loc.png){#fig-pandas-loc}\n\n##### Querying rows {.unnumbered}\n\nWhen we know the exact label of the row or the column, we can use the `.loc` function to query the DataFrame (@fig-pandas-loc). Let's start by querying specific **rows**. @lst-set-index has defined the `Name` column as the *index* (i.e., row label), which means that we can simply pass the name of the volcano.\n\n::: {#5e330823 .cell execution_count=5}\n``` {.python .cell-code}\n# Get the row for \"Calbuco\" volcano\ndf.loc['Calbuco']\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nVEI                            4\nCountry                    Chile\nDate         2015-04-22 00:00:00\nLatitude                -41.2972\nLongitude               -72.6097\nName: Calbuco, dtype: object\n```\n:::\n:::\n\n\nNote that the result is a *Series* (i.e., a 1-dimensional DataFrame where the columns become the index), not a DataFrame. If we want to **keep it as a DataFrame**, we can use double brackets. Double brackets can also be used to query **multiple rows**.\n\n::: {#9196feff .cell execution_count=6}\n``` {.python .cell-code}\ndf.loc[['Calbuco']] # Query one row and return it as a DataFrame\ndf.loc[['Calbuco', 'Taal']] # Query multiple rows\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Calbuco</th>\n      <td>4</td>\n      <td>Chile</td>\n      <td>2015-04-22</td>\n      <td>-41.2972</td>\n      <td>-72.6097</td>\n    </tr>\n    <tr>\n      <th>Taal</th>\n      <td>4</td>\n      <td>Philippines</td>\n      <td>2020-01-12</td>\n      <td>14.0020</td>\n      <td>120.9934</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Question\n\nWhat is the VEI recorded for Etna volcano?\n\n::: {#815e6978 .cell execution_count=7}\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>1</option><option value='0'>2</option><option value='0'>3</option><option value='answer'>4</option><option value='0'>5</option></select>\n```\n:::\n:::\n\n\nWhat is the eruption date for Taal volcano?\n\n::: {#ed180c40 .cell execution_count=8}\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>1980-05-18\t</option><option value='0'>1991-04-02</option><option value='answer'>2020-01-12</option><option value='0'>1997-06-25</option><option value='0'>2023-02-13</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n::: {.callout-tip}\n## Double brackets\nIn general, double brackets ``[[ ]]`` will return a DataFrame and not a Series. We will dominantly use this in the following examples.\n:::\n\n\n##### Querying columns {.unnumbered}\n\nLet's now query specific **columns**. For example, querying the `VEI` column can be achieved in different ways. The simplest is to use the column name directly. We can also query **multiple columns** using double brackets\n\n::: {#a70bf409 .cell execution_count=9}\n``` {.python .cell-code}\ndf[['VEI']] # Get the VEI column\ndf[['Country', 'VEI']] # Query multiple columns\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Country</th>\n      <th>VEI</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>St. Helens</th>\n      <td>USA</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Pinatubo</th>\n      <td>Philippines</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>El Chichón</th>\n      <td>Mexico</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Galunggung</th>\n      <td>Indonesia</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>Nevado del Ruiz</th>\n      <td>Colombia</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Merapi</th>\n      <td>Indonesia</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Ontake</th>\n      <td>Japan</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Soufrière Hills</th>\n      <td>Montserrat</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Etna</th>\n      <td>Italy</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Nyiragongo</th>\n      <td>DR Congo</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>Kīlauea</th>\n      <td>USA</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <th>Agung</th>\n      <td>Indonesia</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Tavurvur</th>\n      <td>Papua New Guinea</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Sinabung</th>\n      <td>Indonesia</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Taal</th>\n      <td>Philippines</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>La Soufrière</th>\n      <td>Saint Vincent</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>Calbuco</th>\n      <td>Chile</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>St. Augustine</th>\n      <td>USA</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>Eyjafjallajökull</th>\n      <td>Iceland</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>Cleveland</th>\n      <td>USA</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nNote that until now, we have only retrieved either rows or columns (@fig-pandas-loc). We can also retrieve specific values by specifying **both the row and the column**.\n\n::: {#d3dc91a4 .cell execution_count=10}\n``` {.python .cell-code}\ndf.loc[['Calbuco', 'Taal']][['Country', 'VEI']]\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Country</th>\n      <th>VEI</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Calbuco</th>\n      <td>Chile</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>Taal</th>\n      <td>Philippines</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n#### Position-based indexing {.unnumbered}\n\n![Position-based queries using `.iloc`.](img/pandas_iloc.png){#fig-pandas-iloc}\n\n\nSome situations require querying data by *location* instead of *label* - let's say for instance we need to retrieve rows 10-20. This is done using the `.iloc` function (instead of the `.loc` function previously used; @fig-pandas-iloc). Remember that Python uses zero-based indexing (@cau-indexing), meaning that the first element is at position 0, the second at position 1, and so on.\n\nThe next example queries the first row - using again double brackets to return a **DataFrame**.\n\n::: {#5cf14a90 .cell execution_count=11}\n``` {.python .cell-code}\ndf.iloc[[0]]\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>St. Helens</th>\n      <td>5</td>\n      <td>USA</td>\n      <td>1980-05-18</td>\n      <td>46.1914</td>\n      <td>-122.1956</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n##### Get ranges of rows {.unnumbered}\n\nWe can get **a range of rows** using what is called *slicing*. This is done using the colon (`:`) operator. The next example queries rows 3 to 6 of the DataFrame. Note that the end index is exclusive, meaning that the element at the end index is not included in the result.\n\n::: {#2ac8303a .cell execution_count=12}\n``` {.python .cell-code}\ndf.iloc[2:6]\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>El Chichón</th>\n      <td>5</td>\n      <td>Mexico</td>\n      <td>1982-03-28</td>\n      <td>17.3559</td>\n      <td>-93.2233</td>\n    </tr>\n    <tr>\n      <th>Galunggung</th>\n      <td>4</td>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n      <td>-7.2567</td>\n      <td>108.0771</td>\n    </tr>\n    <tr>\n      <th>Nevado del Ruiz</th>\n      <td>3</td>\n      <td>Colombia</td>\n      <td>1985-11-13</td>\n      <td>4.8950</td>\n      <td>-75.3220</td>\n    </tr>\n    <tr>\n      <th>Merapi</th>\n      <td>2</td>\n      <td>Indonesia</td>\n      <td>2023-12-03</td>\n      <td>-7.5407</td>\n      <td>110.4457</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nTo get rows 3 to 6 and columns 2-3:\n\n::: {#bf366fb5 .cell execution_count=13}\n``` {.python .cell-code}\ndf.iloc[0:5, 1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Country</th>\n      <th>Date</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>St. Helens</th>\n      <td>USA</td>\n      <td>1980-05-18</td>\n    </tr>\n    <tr>\n      <th>Pinatubo</th>\n      <td>Philippines</td>\n      <td>1991-04-02</td>\n    </tr>\n    <tr>\n      <th>El Chichón</th>\n      <td>Mexico</td>\n      <td>1982-03-28</td>\n    </tr>\n    <tr>\n      <th>Galunggung</th>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n    </tr>\n    <tr>\n      <th>Nevado del Ruiz</th>\n      <td>Colombia</td>\n      <td>1985-11-13</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n##### Count rows from the last {.unnumbered}\n\nTo get the last 5 rows of the DataFrame:\n\n::: {#43d333c2 .cell execution_count=14}\n``` {.python .cell-code}\ndf.iloc[-5:]\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>La Soufrière</th>\n      <td>4</td>\n      <td>Saint Vincent</td>\n      <td>2021-04-09</td>\n      <td>13.2833</td>\n      <td>-61.3875</td>\n    </tr>\n    <tr>\n      <th>Calbuco</th>\n      <td>4</td>\n      <td>Chile</td>\n      <td>2015-04-22</td>\n      <td>-41.2972</td>\n      <td>-72.6097</td>\n    </tr>\n    <tr>\n      <th>St. Augustine</th>\n      <td>3</td>\n      <td>USA</td>\n      <td>2006-03-27</td>\n      <td>57.8819</td>\n      <td>-155.5611</td>\n    </tr>\n    <tr>\n      <th>Eyjafjallajökull</th>\n      <td>4</td>\n      <td>Iceland</td>\n      <td>2010-04-14</td>\n      <td>63.6333</td>\n      <td>-19.6111</td>\n    </tr>\n    <tr>\n      <th>Cleveland</th>\n      <td>3</td>\n      <td>USA</td>\n      <td>2023-05-23</td>\n      <td>52.8250</td>\n      <td>-169.9444</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n##### Combining position-based and label-based queries {.unnumbered}\n\nBy experience, position-based queries is more used on *rows* than *columns*. For instance, we might want to access the first 10 rows because we don't know their associated labels, yet it is less likely that we ignore their *attributes*.\nIt is possible mix label-based and position-based indexing. For example, to get the first 5 rows and the `Country` and `VEI` columns:\n\n::: {#76eaffac .cell execution_count=15}\n``` {.python .cell-code}\ndf.iloc[0:5][['Country', 'VEI']]\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Country</th>\n      <th>VEI</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>St. Helens</th>\n      <td>USA</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Pinatubo</th>\n      <td>Philippines</td>\n      <td>6</td>\n    </tr>\n    <tr>\n      <th>El Chichón</th>\n      <td>Mexico</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <th>Galunggung</th>\n      <td>Indonesia</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <th>Nevado del Ruiz</th>\n      <td>Colombia</td>\n      <td>3</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n### Filtering data {.unnumbered}\n\n#### Comparison operators {.unnumbered}\n\nNow that we have reviewed how to access data, let's now see how to **filter** data using **boolean indexing**. For this, we need to review what are **comparison operators** (@tbl-comparison-operators). Let's assume the following variables:\n\n::: {#93b5fc81 .cell execution_count=16}\n``` {#lst-basic-bool .python .cell-code lst-cap=\"Variables used for illustrating logical operations\"}\na = 1\nb = 2\n```\n:::\n\n\nApplying the comparison operators in @tbl-comparison-operators will produce a variable of type `bool` - which can take only two values: `True` or `False`.\n\n| Operator | Meaning                | Example      | Result      |\n|----------|------------------------|--------------|-------------|\n| `==`     | Equal to               | `a == b`     | `False`     |\n| `!=`     | Not equal to           | `a != b`     | `True`      |\n| `>`      | Greater than           | `a > b`      | `False`     |\n| `<`      | Less than              | `a < b`      | `True`      |\n| `>=`     | Greater than or equal  | `a >= b`     | `False`     |\n| `<=`     | Less than or equal     | `a <= b`     | `True`      |\n\n: Comparison operators in Python. {#tbl-comparison-operators .striped   }\n\nWe can apply comparison operators to DataFrame. Let's say we want to test what rows have a VEI of 4:\n\n::: {#74b4f099 .cell execution_count=17}\n``` {#lst-bool .python .cell-code lst-cap=\"Create a boolean mask\"}\ndf['VEI'] == 4\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nName\nSt. Helens          False\nPinatubo            False\nEl Chichón          False\nGalunggung           True\nNevado del Ruiz     False\nMerapi              False\nOntake              False\nSoufrière Hills     False\nEtna                False\nNyiragongo          False\nKīlauea             False\nAgung               False\nTavurvur            False\nSinabung            False\nTaal                 True\nLa Soufrière         True\nCalbuco              True\nSt. Augustine       False\nEyjafjallajökull     True\nCleveland           False\nName: VEI, dtype: bool\n```\n:::\n:::\n\n\nWe can see that Galunggung, Taal, La Soufrière, Calbuco and Eyjafjallajökull return `True` to this condition. This is great, but what if we want to return the actual rows? We can use @lst-bool as a **mask** to then query the rows using `.loc`.\n\n::: {#b8333760 .cell execution_count=18}\n``` {#lst-bool-query .python .cell-code lst-cap=\"Query data using a boolean mask\"}\nmask = df['VEI'] == 4 # Create a mask\ndf.loc[mask] # Query the data\n\n# Or, as a one line alternative:\ndf.loc[df['VEI'] == 4]\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Galunggung</th>\n      <td>4</td>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n      <td>-7.2567</td>\n      <td>108.0771</td>\n    </tr>\n    <tr>\n      <th>Taal</th>\n      <td>4</td>\n      <td>Philippines</td>\n      <td>2020-01-12</td>\n      <td>14.0020</td>\n      <td>120.9934</td>\n    </tr>\n    <tr>\n      <th>La Soufrière</th>\n      <td>4</td>\n      <td>Saint Vincent</td>\n      <td>2021-04-09</td>\n      <td>13.2833</td>\n      <td>-61.3875</td>\n    </tr>\n    <tr>\n      <th>Calbuco</th>\n      <td>4</td>\n      <td>Chile</td>\n      <td>2015-04-22</td>\n      <td>-41.2972</td>\n      <td>-72.6097</td>\n    </tr>\n    <tr>\n      <th>Eyjafjallajökull</th>\n      <td>4</td>\n      <td>Iceland</td>\n      <td>2010-04-14</td>\n      <td>63.6333</td>\n      <td>-19.6111</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Question\n\nWhat volcanoes have a VEI of 5?\n\n::: {#c6cd8a1a .cell execution_count=19}\n\n::: {.cell-output .cell-output-display execution_count=19}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>La Soufrière and Calbuco</option><option value='0'>Merapi and Agung</option><option value='0'>Nyiragongo and Taal</option><option value='answer'>St. Helens and El Chichón</option></select>\n```\n:::\n:::\n\n\nHow many volcanoes are in the southern hemisphere? (hint: use the `df.shape` function to count them).\n\n::: {#0855e1c6 .cell execution_count=20}\n\n::: {.cell-output .cell-output-display execution_count=20}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>1</option><option value='0'>2</option><option value='0'>4</option><option value='answer'>6</option><option value='0'>12</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n##### String comparisons {.unnumbered}\n\nWe can also use comparison operators on columns containing **strings** (see @cau-dtypes for caveats). @lst-str-comp illustrates a basic string comparison using the `=` operator. @tbl-comparison-str shows additional operators for strings.\n\n::: {#ecbb64db .cell execution_count=21}\n``` {#lst-str-comp .python .cell-code lst-cap=\"Basic comparison operation on strings\"}\ndf.loc[df['Country'] == 'Indonesia']\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Galunggung</th>\n      <td>4</td>\n      <td>Indonesia</td>\n      <td>1982-04-05</td>\n      <td>-7.2567</td>\n      <td>108.0771</td>\n    </tr>\n    <tr>\n      <th>Merapi</th>\n      <td>2</td>\n      <td>Indonesia</td>\n      <td>2023-12-03</td>\n      <td>-7.5407</td>\n      <td>110.4457</td>\n    </tr>\n    <tr>\n      <th>Agung</th>\n      <td>3</td>\n      <td>Indonesia</td>\n      <td>2017-11-21</td>\n      <td>-8.3422</td>\n      <td>115.5083</td>\n    </tr>\n    <tr>\n      <th>Sinabung</th>\n      <td>3</td>\n      <td>Indonesia</td>\n      <td>2023-02-13</td>\n      <td>3.1719</td>\n      <td>98.3925</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n| Operation         | Example                                 | Description                                         |\n|-------------------|-----------------------------------------|-----------------------------------------------------|\n| Contains          | `df['Name'].str.contains('Soufrière')`  | Checks if each string contains a substring          |\n| Startswith        | `df['Name'].str.startswith('E')`        | Checks if each string starts with a substring       |\n| Endswith          | `df['Name'].str.endswith('o')`          | Checks if each string ends with a substring         |\n\n\n: Common string comparison operations. {#tbl-comparison-str .striped   }\n\n\n::: {#cau-dtypes .callout-caution collapse=\"true\"}\n## Compare what is comparable!\n\nWhen using the comparison operators in @tbl-comparison-operators, we need to make sure that we are comparing data that have the **same type**. In @lst-bool, we are comparing the column `VEI` with an integer number. You can check the data type of a DataFrame using `df.dtypes`. \n\nNot all comparison operators work with all data type. For instance, you can test if a column contains a specific string using the `==` or `!=` operators, but the other won't work as they are *illogical*.\n:::\n\n#### Logical operators {.unnumbered}\n\nBut what if we want to create more complex filters based on different rules? We can use **logical operators** to combine several comparison operators. Going back to the example in @lst-basic-bool, @tbl-logical-operators illustrates the use of logical operators.\n\n| Operator | Meaning                 | Example                        | Result      |\n|----------|-------------------------|--------------------------------|-------------|\n| `&`      | Logical AND             | `(a > 1) & (b < 3)`            | `False`     |\n| `|`      | Logical OR              | `(a == 1) | (b == 1)`           | `True`      |\n| `~`      | Logical NOT             | `~(a == 1)`                    | `False`     |\n\n: Logical operators in pandas for combining boolean conditions. Use parentheses around each condition. {#tbl-logical-operators .striped }\n\nLet's gather all volcanoes that have a VEI of 3 and are in Indonesia:\n\n::: {#eff12b2c .cell execution_count=22}\n``` {#lst-logical-query .python .cell-code lst-cap=\"Complex filtering using logical operators\"}\nmask = (df['VEI'] == 3) & (df['Country'] == 'Indonesia') # Create a mask - don't forget parentheses!\ndf.loc[mask] # Query the data\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>VEI</th>\n      <th>Country</th>\n      <th>Date</th>\n      <th>Latitude</th>\n      <th>Longitude</th>\n    </tr>\n    <tr>\n      <th>Name</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Agung</th>\n      <td>3</td>\n      <td>Indonesia</td>\n      <td>2017-11-21</td>\n      <td>-8.3422</td>\n      <td>115.5083</td>\n    </tr>\n    <tr>\n      <th>Sinabung</th>\n      <td>3</td>\n      <td>Indonesia</td>\n      <td>2023-02-13</td>\n      <td>3.1719</td>\n      <td>98.3925</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Question\n\nHow many volcanoes are either in Chile **or** in the USA?\n\n::: {#503493ff .cell execution_count=23}\n\n::: {.cell-output .cell-output-display execution_count=23}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>1</option><option value='0'>3</option><option value='answer'>5</option><option value='0'>8</option></select>\n```\n:::\n:::\n\n\nHow many volcanoes are in the southern hemisphere **and** have a VEI≥4?\n\n::: {#f5e5f371 .cell execution_count=24}\n\n::: {.cell-output .cell-output-display execution_count=24}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>1</option><option value='answer'>2</option><option value='0'>8</option><option value='0'>12</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n\n### Rearranging data {.unnumbered}\n\n#### Sorting data {.unnumbered}\n\nThe main function to sort data is `.sort_values` ([doc](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.sort_values.html)). It is necessary to review how *three arguments* can alter the function's behaviour:\n\n1. `by`: First argument (required) is the label of index/row used to sort the data. It is possible to sort by multiple columns by passing a list of values.\n2. `axis`: Specifies whether sorting rows (`axis = 0` - in which case `by` is a column name) or sorting columns (`axis = 1`, in which case `by` is an index value). The documentation specifies `axis = 0`, which means that rows will be sorted if `axis` is not specified.\n3. `ascending`: Using a *bool* (remember, this is a True/False behaviour), specifies if values are sorted in *ascending* (`ascending = True`, default behaviour is not specified) or *descending* (`ascending = False`) order.\n\n::: {#4f778830 .cell execution_count=25}\n``` {#lst-sort .python .cell-code lst-cap=\"Basic sorting operations\"}\ndf.sort_values('VEI') # Sort volcanoes by VEI in ascending number\ndf.sort_values('Date', ascending=False) # Sort volcanoes by eruption dates from recent to old\ndf.sort_values('Country') # .sort_values also work on strings to sort alphabetically\ndf.sort_values(['Latitude', 'Longitude']) # Sorting using multiple columns\n```\n:::\n\n\n::: {.callout-note}\n## Question\n\nAfter sorting the data in **descending order** by VEI and time, what are the three first volcanoes?\n\n::: {#b50cbe91 .cell execution_count=26}\n\n::: {.cell-output .cell-output-display execution_count=25}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>Nyiragongo, Ontake, Kīlauea</option><option value='0'>Kīlauea, Ontake, Nyiragongo</option><option value='answer'>Pinatubo, El Chichon, St Helens</option><option value='0'>St Helens, El Chichon, Pinatubo</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n\n### Operations {.unnumbered}\n\nLet's now see how we can manipulate and operate on data contained within our DataFrame. @tbl-op-arith and @tbl-op-str respectively illustrate arithmetic and string-based operators that can be applied on parts of the DataFrame.\n\n\n#### Numeric operations {.unnumbered}\n\n@lst-op1 Illustrates how to half the VEI column save the results to a new column.\n\n::: {#3102e8ce .cell execution_count=27}\n``` {#lst-op1 .python .cell-code lst-cap=\"Divide VEI by two and save the results to a new column.\"}\ndf['VEI_halved'] = df['VEI'] / 2\n```\n:::\n\n\n::: {.callout-note}\n## Exercise\n\nLongitudes are expressed as degrees E (i.e., from 0–180 ) and degrees W (i.e., from -180–0). Use operators to convert longitudes to degrees E (i.e., from 0–360) and store the results to a column called `Longitude_E`. To do so:\n\n1. Define a mask where Longitudes are negative using [logical operators]\n2. Where the mask is `True` (i.e. where the longitude is negative), add the longitude (or subtract its absolute value) to 360\n\n\n::: {.callout-tip collapse=\"true\"}\n## Define a mask\nStart by defining a mask\n\n::: {.callout-tip collapse=\"true\"}\n## How?\n\n```python\nmask = df['Longitude'] <= 0\n```\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Select the values\nSelect the values using `.loc` and do the maths.\n\n::: {.callout-tip collapse=\"true\"}\n## How?\n\n```python\n360 + df.loc[mask, 'Longitude']\n```\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Store back the values\n\n```python\ndf.loc[mask, 'Longitude_E'] = 360 + df.loc[mask, 'Longitude']\n```\n:::\n\n\n:::\n\n| Operation      | Symbol | Example                | Description                                 |\n|----------------|--------|------------------------|---------------------------------------------|\n| Addition       | `+`    | `df['VEI'] + 1`        | Adds a value to each element                |\n| Subtraction    | `-`    | `df['VEI'] - 1`        | Subtracts a value from each element         |\n| Multiplication | `*`    | `df['VEI'] * 2`        | Multiplies each element by a value          |\n| Division       | `/`    | `df['VEI'] / 2`        | Divides each element by a value             |\n| Exponentiation | `**`   | `df['VEI'] ** 2`       | Raises each element to a power              |\n| Modulo         | `%`    | `df['VEI'] % 2`        | Remainder after division for each element   |\n\n: Common arithmetic operations on numerical pandas columns. {#tbl-op-arith .striped   }\n\n\n\n#### String operations {.unnumbered}\n\n\n\n| Operation         | Example                                 | Description                                         |\n|-------------------|-----------------------------------------|-----------------------------------------------------|\n| Concatenation     | `df['Country'] + ' volcano'`            | Adds a string to each element                       |\n| String length     | `df['Country'].str.len()`                  | Returns the length of each string                   |\n| Uppercase         | `df['Country'].str.upper()`             | Converts each string to uppercase                   |\n| Lowercase         | `df['Country'].str.lower()`             | Converts each string to lowercase                   |\n| Replace           | `df['Country'].str.replace('USA', 'US')`| Replaces substrings in each string                  |\n\n: Common string operations on pandas columns. {#tbl-op-str .striped   }\n\n",
    "supporting": [
      "pandas1_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}