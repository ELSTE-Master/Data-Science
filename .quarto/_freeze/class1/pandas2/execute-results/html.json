{
  "hash": "f242f1961ab618d33fb5c579b759d295",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Data exploration\"\nformat:\n  html:\n    code-fold: false\n    code-line-numbers: true\n    css: [../assets/webex.css]\n    include-after-body: [../assets/webex.js]\n    embed-resources: true \njupyter: python3\n---\n\n\n\n## Introduction\n\n### Today's objectives {.unnumbered}\n\n## Setting up the exercise\n\nWe start by importing libraries and the dataset.\n\n::: {#c1200762 .cell execution_count=2}\n``` {#lst-load-geochem .python .cell-code lst-cap=\"caption\"}\n# Load libraries\nimport pandas as pd # Import pandas\nimport matplotlib.pyplot as plt # Import the pyplot module from matplotlib\nimport seaborn as sns # Import seaborn\n\n# Import the dataset specifying which Excel sheet name to load the data from\ndf = pd.read_excel('../Data/Smith_glass_post_NYT_data.xlsx', sheet_name='Supp_traces')\n```\n:::\n\n\nAs in [the previous class](pandas1.qmd), we load the dataset using **Pandas**. The dataset comes from @Smith2011 and contains the chemical concentrations in volcanic tephra belonging to the recent activity (last 15 ky) of the Campi Flergrei Caldera (Italy). The dataset is contained in an Excel file that contains two sheets named `'Supp_majors'` and `'Supp_traces'`. In @lst-load-geochem, we use the `sheet_name` argument to the `read_excel()` ([doc](https://pandas.pydata.org/docs/reference/api/pandas.read_excel.html)) function to specify that we want to load the sheet containing trace elements.\n\n::: {.callout-tip}\n## Good reference book\n\nThe use of this dataset is inspired by the by the book *Introduction to Python in Earth Science Data Analysis: From Descriptive Statistics to Machine Learning* by @Petrelli2021.\n:::\n\n\n### Basics of plotting in Python {.unnumbered}\n\n@lst-load-geochem also loads two libraries for plotting:\n\n- [**Matplotlib**](https://matplotlib.org/stable/users/explain/quick_start.html) is [the library]{.mark} for plotting in Python. It allows for the finest and most comprehensive level of customisation, but it take some time to get used to. You can visit the [gallery](https://matplotlib.org/stable/gallery/index.html) to get some inspiration.\n- [**Seaborn**](https://seaborn.pydata.org/tutorial/introduction) is [built on Matplotlib]{.mark}, but provides some higher-level functions to easily produce stats-oriented plots. It looks good by default, but finer customisation might be difficult and might result to using Matplotlib. Again, check out the [gallery](https://seaborn.pydata.org/examples/index.html).\n\nHere again, the idea is not to make you expert in *Matplotlib* or *Seaborn*, but rather to provide you with the minimum knowledge for you to further explore this tools in the context of your research.\n\n#### Components of a Figure {.unnumbered}\n\nLet's start to look at the basic components of a *Matplotlib* figure. There are two \"hosts\" to any plot (@fig-fig-anatomy-1):\n\n1. A [**Figure**]{.mark} represents the main canevas;\n2. [**Axes**]{.mark} are contained within the figure and is where most of the plotting will occur.\n\nThe easiest way to define a figure is using the `subplots()` function (@lst-plt-set). Note that the code returns two variables - `fig` and `ax` - which are the figure and the axes, respectively.\n\n::: {#154d148e .cell execution_count=3}\n``` {#lst-plt-set .python .cell-code lst-cap=\"Define a figure and one axes.\"}\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots()\n```\n:::\n\n\n![Main figure and axes of a *Matplotlib* figure](img/fig-anatomy-1.png){#fig-fig-anatomy-1}\n\n\nMost additional components of a plot are controlled via the `ax` variable, which can be used to (@fig-fig-anatomy-2):\n\n- *Plot* (e.g., line plot or scatter plots)\n- *Set labels* (e.g., x-label, y-label, title)\n- Add various *components* (e.g., legend, grid)\n\n![Basic components of a *Matplotlib* figure](img/fig-anatomy-2.png){#fig-fig-anatomy-2}\n\n::: {.callout-note}\n\n## Plotting exercise\n\n@lst-plt-ex1 defines a figure and plots some data. @tbl-mpl-basics and @fig-fig-anatomy-2 illustrate some of the most frequently used functions for customising plots.\n\nUse these functions to customise @lst-plt-ex1. Some hints:\n\n- Remember that a *function* takes some *arguments* provided between *parentheses* (e.g., `ax.title(argument)`). Each function might accept different types of arguments.\n- Titles and labels require a *string*, so remember to use `\" \"` or `' '`.\n- For now, the legend does not require any argument, so you can leave the parentheses empty.\n- Setting the grid requires one argument: do we want to show the grid (`True`) or not (`False`)\n\n:::\n\n| Function        | Description                        | Argument Type         | Example Argument           |\n|-----------------|------------------------------------|-----------------------|----------------------------|\n| [`ax.set_title`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_title.html)    | Sets the title of the axes         | str                   | \"My Plot Title\"            |\n| [`ax.set_xlabel`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_xlabel.html)   | Sets the label for the x-axis      | str                   | \"X Axis Label\"             |\n| [`ax.set_ylabel`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.set_ylabel.html)   | Sets the label for the y-axis      | str                   | \"Y Axis Label\"             |\n| [`ax.legend`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.legend.html)       | Displays the legend                | None    | None (default)  |\n| [`ax.grid`](https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.grid.html)         | Shows grid lines                   | bool           | True             |\n\n: Some of the most frequently used plotting functions. {#tbl-mpl-basics .striped   }\n\n::: {#9542949d .cell execution_count=4}\n``` {#lst-plt-ex1 .python .cell-code lst-cap=\"Define a figure and one axes.\"}\nimport matplotlib.pyplot as plt # Import matplotlib\n\n# Define some data\ndata1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\ndata2 = [7, 3, 9, 1, 5, 10, 8, 2, 6, 4]\n\n# Set the figure and the axes\nfig, ax = plt.subplots()\n\n# Plot the data\nax.plot(data1, data1, color='aqua', label='Line')\nax.scatter(data1, data2, color='purple', label='scatter')\n\n# Customise the plot - up to you!\n# - Add a title\n# - Add x and y labels\n# - Add a legend\n# - Add a grid\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n### Plotting with Seaborn {.unnumbered}\n\nLet's now review the use of **Seaborn**. You might wonder [why do we need another plotting library]{.mark}. Well, the topic of this module is [data exploration]{.mark}, and this is exactly what *Seaborn* is designed for. In additions, *Seaborn* is designed to work with *Pandas*.\n\nOver the next steps of the exercise we will use various types of plots offered by *Seaborn* to explore our geochemical dataset. @lst-sns-intro illustrates how to create a [scatterplot](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) of the [Rubidium]{.mark} and [Strontium]{.mark} values contained in our dataset `df`. *Seaborn* usually takes [4 arguments]{.mark}:\n\n1. `ax`: The axes on which to plot the data\n2. `data`: The DataFrame containing the data.\n3. `x`: The name of the column containing the values used along x\n4. `y`: The name of the column containing the values used along y\n\n::: {#11d36771 .cell execution_count=5}\n``` {#lst-sns-intro .python .cell-code lst-cap=\"Basic plotting using Seaborn.\"}\n# Define figure + axes\nfig, ax = plt.subplots()\n# Plot with seaborn (remember, we imported it as sns)\n# df is the geochemical dataset imported previously\nsns.scatterplot(ax=ax, data=df, x='Rb', y='Sr')\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-6-output-1.png){}\n:::\n:::\n\n\nShould you feel adventurous and check out the [documentation](https://seaborn.pydata.org/generated/seaborn.scatterplot.html) of the `scatterplot` function, you would see that it is possible to use [additional arguments]{.mark} to further customize the plot:\n\n- `hue`: Name of the variable that will produce points with [different colors]{.mark}.\n- `size`: Name of the variable that will produce points with [different sizes]{.mark}.\n\n::: {.callout-note}\n\n## Seaborn exercise\n\nComplete @lst-sns-intro, but use:\n\n- The `\"Epoch\"` column to control points color.\n- The `\"SiO2* (EMP)\"` column to control points size.\n\nRemember, you can use `df.columns` to print a list of column names contained in the DataFrame.\n\n:::\n\n\n\n## Descriptive statistics\n\n\n### Univariate statistics  {.unnumbered}\n\nThe objective of **descriptive statistics** is to [provide ways of capturing the properties of a given data set or sample]{.mark}. Using *Pandas* and *Seaborn*, we will review some [metrics, tools, and strategies]{.mark} that can be used to summarize a dataset, providing us with a quantitative basis to talk about it and compare it to other datasets.\n\nBy **univariate statistics**, we focus on [capturing the properties of **single** variables at the time]{.mark}. We are not yet concerned in characterising the [relationships]{.mark} between two or more variables.\n\nLet's focus on the Zircon concentration in Campi Flegrei's geochemical dataset. Let's start by simply [visualising]{.mark} the dataset to get an understanding of what we will talk about. Figures below illustrate three different plot types:\n\n1. **Histograms** ([`sns.histplots()`](https://seaborn.pydata.org/generated/seaborn.histplot.html)) show the [number of times a specific Zr concentration occurs]{.mark} in our dataset (@lst-sns-hist).\n2. **Box plots** ([`sns.boxplot()`](https://seaborn.pydata.org/generated/seaborn.boxplot.html) - or box-and-whisker plot) show the [distribution of quantitative data]{.mark} with some measure of dispersion. Note that they are useful to compare between variables (@lst-sns-boxplot). \n3. **Violin plots** ([`sns.violinplot()`](https://seaborn.pydata.org/generated/seaborn.violinplot.html)) are similar to box plots, but they approximate the underlying data distribution using some smoothing algorithm (i.e. *kernel density estimation*). Without going into too much detail, this provides a good first approximation of the distribution, but [it can create some unrealistic artefacts]{.mark} (e.g., see the negative Sr concentrations in @lst-sns-violinplot).\n\n::: {.panel-tabset}\n\n## Histogram\n\n::: {#ee30511b .cell execution_count=6}\n``` {#lst-sns-hist .python .cell-code lst-cap=\"Visualising distributions using histograms.\"}\nfig, ax = plt.subplots()\nsns.histplot(data=df, x='Zr')\nax.set_xlabel('Zr (ppm)');\nax.set_title('Zr distribution');\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n## Box plot\n\n::: {.callout-tip}\n## Plotting several columns\n\nBox plots are useful to plot and compare more than one data. @lst-sns-boxplot slightly adjusts how `boxplot()` is called to allow for that.\n\n:::\n\n::: {#10af4441 .cell execution_count=7}\n``` {#lst-sns-boxplot .python .cell-code lst-cap=\"Visualising distributions using box-and-whisker plots.\"}\nfig, ax = plt.subplots()\nsns.boxplot(data=df[['Zr', 'Sr']]) # We plot Zr and Sr together using a list\nax.set_ylabel('Concentration (ppm)');\nax.set_title('Zr and Sr distribution');\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n## Violin plot\n\n::: {#7c984a1b .cell execution_count=8}\n``` {#lst-sns-violinplot .python .cell-code lst-cap=\"Visualising distributions using violin plots.\"}\nfig, ax = plt.subplots()\nsns.violinplot(data=df[['Zr', 'Sr']])\nax.set_xlabel('Concentration (ppm)');\nax.set_title('Zr and Sr distribution');\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\n:::\n\n\nBy looking at the Zr and St distributions from the figures above, we can intuitively understand the importance of describing [three different parameters]{.mark}:\n\n- The **location** - or where is [the central value(s)]{.mark} of the dataset;\n- The **dispersion** - or how [spread out]{.mark} is the distribution of data compared to the central values;\n- The **skewness** - or how [symmetrical]{.mark} is the distribution of data compared to the central values;\n\n\n#### Location {.unnumbered}\n\n##### Mean {.unnumbered}\n\nThe **mean** (or *arithmetic* mean - by opposition to *geometric* or *harmonic* means) is the [sum of the values divided by the number of values]{.mark} (@eq-mean):\n\n$$\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$ {#eq-mean}\n\nThe mean is meaningful to describe [**symmetric** distributions without **outliers**]{.mark}, where:\n\n- **Symmetric** means the number of items above the mean should be roughly the same as the number below;\n- **Outliers** are *extreme* values.\n\nThe mean of a dataset can easily be computed with *Pandas* using the [`.mean()`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mean.html) function (@lst-univ-mean). Note that we round the results to two significant digits using `.round(2)`.\n\n::: {#6089908e .cell execution_count=9}\n``` {#lst-univ-mean .python .cell-code lst-cap=\"Compute the mean for two significant digits.\"}\ndf['Zr'].mean().round(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=110}\n```\n365.38\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Question\n\nWhat is the mean value for Strontium?\n\n::: {#0a3e4f11 .cell execution_count=10}\n\n::: {.cell-output .cell-output-display execution_count=111}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>365.38</option><option value='answer'>516.42</option><option value='0'>219.38</option><option value='0'>123.94</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n\n\n\n::: {.callout-tip}\n## Descriptive stats functions\n\n@lst-univ-mean shows how to compute the mean on one column, but the `.mean()` function - as well as most fuctions for descriptive stats - can be applied to entire DataFrames. For this, we need to understand a critical argument - `axis`.\n\n- `axis = 0` is usually the default, and computes the mean [across all rows for each column]{.mark}(@lst-univ-mean-multi-row)\n- `axis = 1` usually makes sense when rows are labelled, and computes the mean [across all columns for each row]{.mark}(@lst-univ-mean-multi-col)\n\n::: {#6ab46e93 .cell execution_count=11}\n``` {#lst-univ-mean-multi-row .python .cell-code lst-cap=\"Compute the mean across rows.\"}\n# Create a subset of the df containing numerical data\ndf_sub = df[['Sc','Rb','Sr','Y','Zr','Nb','Cs']] \n# Compute the mean across all rows\ndf_sub.mean(axis=0).round(2).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=112}\n```\nSc      0.20\nRb    343.82\nSr    516.42\nY      31.33\nZr    365.38\ndtype: float64\n```\n:::\n:::\n\n\n::: {#6552836c .cell execution_count=12}\n``` {#lst-univ-mean-multi-col .python .cell-code lst-cap=\"Compute the mean across columns.\"}\n# Create a subset of the df containing numerical data\ndf_sub = df[['Sc','Rb','Sr','Y','Zr','Nb','Cs']] \n# Compute the mean across all columns\ndf_sub.mean(axis=1).round(2).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=113}\n```\n0    198.32\n1    188.41\n2    188.48\n3    200.69\n4    198.42\ndtype: float64\n```\n:::\n:::\n\n\n:::\n\n\n\n\n##### Median {.unnumbered}\n\nThe **median** is the value [at the exact middle of the dataset]{.mark}, meaning that just as\nmany elements lie above the median as below it. There is no easy formula to compute the median, instead we need to conceptually (@lst-univ-median-ex):\n\n1. Order all values in ascending order and plot them against a normalised number of observations (this is called an empirical cumulative density function - or ECDF);\n2. On the x-axis, find the point dividing the dataset into two equal numbers of observations;\n3. Read the value on the y-axis that intersects the ECDF.\n\n::: {#58904f62 .cell execution_count=13}\n``` {#lst-univ-median-ex .python .cell-code lst-cap=\"Graphical representation of the median.\"}\nfig, ax = plt.subplots()\nsns.ecdfplot(data=df, y='Zr')\nax.plot([.5,.5], [0, df['Zr'].median()], color='orange', linestyle='--')\nax.plot([.5,0], [df['Zr'].median(), df['Zr'].median()], color='orange', linestyle='--')\nax.set_ylim([0,900])\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-14-output-1.png){}\n:::\n:::\n\n\nFortunately, we can also use the native *Pandas* [`.median`](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.median.html) function (@lst-univ-median). \n\n::: {#6251515c .cell execution_count=14}\n``` {#lst-univ-median .python .cell-code lst-cap=\"Compute the median for two significant digits.\"}\ndf['Zr'].median().round(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=115}\n```\n339.41\n```\n:::\n:::\n\n\n::: {.callout-note}\n## Question\n\nWhat is the mean value for Cesium?\n\n::: {#f16929ff .cell execution_count=15}\n\n::: {.cell-output .cell-output-display execution_count=116}\n```{=html}\n<select class='webex-select'><option value='blank'></option><option value='0'>36.38</option><option value='answer'>51.42</option><option value='answer'>23.99</option><option value='0'>13.94</option></select>\n```\n:::\n:::\n\n\n:::\n\n\n<!-- ##### Mode {.unnumbered}\n\n[mode](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.mode.html)\n -->\n\n##### Summary {.unnumbered}\n\n@lst-univ-mean-med illustrate the values of the mean and the median relative to the distribution shown in the histogram. There are a few things to keep in mind when choosing between mean and median to estimate the location of a dataset:\n\n- If a sample has a [symmetrical distribution]{.mark}, then **the mean and median are equal**.\n- If the distribution of a sample is [not symmetrical]{.mark}, **the mean should not be used**.\n- The [mean is highly sensitive to outliers]{.mark}, whereas the median is not.\n\n::: {#60316014 .cell execution_count=16}\n``` {#lst-univ-mean-med .python .cell-code lst-cap=\"Compute the median for two significant digits.\"}\nfig, ax = plt.subplots()\nsns.histplot(data=df, x='Zr')\nax.axvline(df['Zr'].mean(), color='darkorange', lw=3, label='Mean')\nax.axvline(df['Zr'].median(), color='darkviolet', lw=3, label='Median')\nax.legend()\n```\n\n::: {.cell-output .cell-output-display}\n![](pandas2_files/figure-html/cell-17-output-1.png){}\n:::\n:::\n\n\n#### Dispersion x {.unnumbered}\n\n#### Skewness x {.unnumbered}\n\n### Bivariate statistics x {.unnumbered}\n\n#### Correlation x {.unnumbered}\n\n#### Simple linear regression x {.unnumbered}\n\n",
    "supporting": [
      "pandas2_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}